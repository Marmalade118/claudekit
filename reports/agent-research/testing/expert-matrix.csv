Category,Symptom/Error,Root Cause,Fix 1,Fix 2,Fix 3,Diagnostic Command,Validation Step,Official Link
Test Structure & Organization,Tests are hard to maintain and understand,Lack of testing conventions,Group related tests with describe blocks,Create shared test utilities and fixtures,Implement testing pyramid with clear boundaries,npx test --help,Check test readability and DRY principles,https://jestjs.io/docs/getting-started
Test Structure & Organization,Duplicated setup code across test files,No shared test utilities,Extract common setup to beforeEach,Create reusable test factories,Implement proper test architecture patterns,grep -r beforeEach tests/,Verify setup code is reused not duplicated,https://jestjs.io/docs/setup-teardown
Test Structure & Organization,Poor test naming conventions,Unclear test descriptions,Use descriptive test names,Follow arrange-act-assert pattern,Implement BDD-style test naming,grep -r "test\|it" tests/,Ensure test names describe behavior not implementation,https://testing-library.com/docs/queries/about
Test Structure & Organization,Mixed unit and integration tests,No clear test boundaries,Separate unit from integration tests,Create different test suites per type,Follow testing pyramid principles,find tests/ -name "*test*" | head -20,Verify test types are properly separated,https://playwright.dev/docs/best-practices
Mocking & Test Doubles,Tests breaking when dependencies change,Tight coupling in code under test,Use jest.clearAllMocks() in beforeEach,Implement dependency injection patterns,Apply hexagonal architecture for testability,npm test -- --verbose,Run tests and check for brittle failures,https://jestjs.io/docs/mock-functions
Mocking & Test Doubles,Over-mocking making tests brittle,Testing implementation over behavior,Mock only external dependencies,Focus on testing behavior not internals,Implement contract testing,grep -r "jest.mock\|vi.mock" tests/,Review mock usage for necessity,https://vitest.dev/guide/mocking
Mocking & Test Doubles,Confusion between spies stubs and mocks,Misunderstanding of test double types,Learn difference between test doubles,Use appropriate double for each case,Apply test double patterns consistently,grep -r "jest.fn\|jest.spyOn" tests/,Verify correct test double usage,https://jestjs.io/docs/jest-object
Mocking & Test Doubles,Mocks not being reset between tests,No mock cleanup strategy,Add jest.clearAllMocks() to beforeEach,Use fresh mocks per test file,Implement automatic mock cleanup,jest --clearMocks,Check mocks are isolated between tests,https://jestjs.io/docs/configuration#clearmocks
Async & Timing Issues,Intermittent test failures,Missing await keywords,Add proper await/async patterns,Mock timers and async dependencies,Implement deterministic async testing patterns,npm test -- --runInBand,Run tests serially to identify timing issues,https://jestjs.io/docs/troubleshooting
Async & Timing Issues,act warnings in React tests,Improper handling of promises,Wrap async updates in act(),Use async/await consistently,Implement proper async testing patterns,npm test 2>&1 | grep -i "act",Check for React act warnings,https://testing-library.com/docs/dom-testing-library/api-async
Async & Timing Issues,Tests timing out,Real timers in tests,Use fake timers with jest.useFakeTimers(),Mock async operations properly,Design async-friendly test architecture,npm test -- --detectLeaks,Check for hanging promises and timers,https://jestjs.io/docs/timer-mocks
Async & Timing Issues,Race conditions in async operations,Uncontrolled async side effects,Use waitFor for async assertions,Mock external async dependencies,Implement controlled async execution,npm test -- --no-cache,Clear cache and rerun for consistency,https://testing-library.com/docs/dom-testing-library/api-async
Coverage & Quality Metrics,Low test coverage reports,Coverage-driven testing instead of behavior-driven,Set up basic coverage reporting,Implement branch and line coverage thresholds,Add mutation testing and quality gates,npm test -- --coverage,Review coverage reports for gaps,https://vitest.dev/guide/coverage
Coverage & Quality Metrics,Coverage doesn't reflect actual test quality,Missing edge case testing,Add tests for error paths,Focus on behavior coverage not line coverage,Implement quality metrics beyond coverage,npm run coverage -- --reporter=text,Analyze coverage quality not just quantity,https://jestjs.io/docs/configuration#collectcoverage
Coverage & Quality Metrics,Untested edge cases and error paths,No mutation testing,Test error conditions explicitly,Add property-based testing,Implement comprehensive test strategies,grep -r "throw\|catch" src/ | wc -l,Count error paths and ensure testing,https://github.com/stryker-mutator/stryker-js
Coverage & Quality Metrics,False confidence from high coverage,Unclear coverage thresholds,Set meaningful coverage thresholds,Implement multiple quality metrics,Add code review process for test quality,npm test -- --coverage --coverageThreshold,Set and enforce coverage thresholds,https://jestjs.io/docs/configuration#coveragethreshold
Integration & E2E Testing,Slow test suites,No test parallelization,Enable test parallelization,Implement test sharding and caching,Optimize test architecture for CI,npm test -- --maxWorkers=4,Monitor test execution time,https://jestjs.io/docs/cli#--maxworkers-num--string
Integration & E2E Testing,Tests failing in CI but passing locally,Environment differences,Ensure environment parity,Use test containers and fixtures,Create hermetic test environments,CI_ENV=true npm test,Test with CI environment variables,https://playwright.dev/docs/ci-intro
Integration & E2E Testing,Database state pollution between tests,Shared state between tests,Isolate test data with transactions,Use test database per test,Implement proper test data management,grep -r "beforeEach\|afterEach" tests/,Verify test isolation patterns,https://playwright.dev/docs/test-fixtures
Integration & E2E Testing,Complex test environment setup,No test data management strategy,Create database factories,Use Docker for test environments,Implement infrastructure as code for tests,docker-compose -f test-compose.yml up,Verify test environment consistency,https://testcontainers.com/
CI/CD & Performance,Tests taking too long to run,Poor test organization,Enable test parallelization,Implement test sharding and caching,Optimize test architecture for CI,time npm test,Measure and optimize test execution time,https://vitest.dev/guide/improving-performance
CI/CD & Performance,Flaky tests in CI pipelines,Resource leaks in tests,Implement test retry mechanisms,Use deterministic test patterns,Create stable test infrastructure,npm test -- --retries=3,Configure retries for flaky tests,https://playwright.dev/docs/test-retries
CI/CD & Performance,Memory leaks in test runs,No test resource management,Monitor memory usage during tests,Implement proper cleanup patterns,Use memory profiling tools,npm test -- --logHeapUsage,Monitor heap usage during tests,https://jestjs.io/docs/cli#--logheapusage
CI/CD & Performance,Inconsistent test results across environments,Environment differences,Standardize test environments,Use containerized testing,Implement infrastructure as code,env NODE_ENV=test npm test,Test with production-like environment,https://playwright.dev/docs/test-configuration